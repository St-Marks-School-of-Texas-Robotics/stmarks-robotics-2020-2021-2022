#pragma config(Sensor, dgtl10,  CLAW_FL_SWITCH, sensorDigitalIn)
#pragma config(Sensor, dgtl8,  CLAW_BL_SWITCH, sensorDigitalIn)
#pragma config(Sensor, dgtl9,  CLAW_FR_SWITCH, sensorDigitalIn)
#pragma config(Sensor, dgtl7,  CLAW_BR_SWITCH, sensorDigitalIn)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define left_claw_port port4
#define right_claw_port port5

int curState = 0;
int prevState = 0;

bool curSlow = false;
bool prevSlow = false;

bool curA = false;
bool prevA = false;
bool curB = false;
bool prevB = false;

bool curC = false;
bool prevC = false;
bool curD = false;
bool prevD = false;

int up = 0;
int down = 0;
int left = 0;
int right = 0;


char posR = NULL;
char prevPosR = NULL;
bool slowR = false;

char posL = NULL;
char prevPosL = NULL;
bool slowL = false;


task main()
{
	while (true){


		if (vexRT[Ch1] > 25) {
				right = 1;
			} else {
				right = 0;
			}

			if (vexRT[Ch1] < -25) {
				left = 1;
			} else {
				left = 0;
			}

	// Right claw forward


			if (right == 1) { //button held
				curA = true;

				if (curA && !prevA) { //rising edge
					//clearTimer(T1);
				}

				if (SensorValue[CLAW_FR_SWITCH] == 1) { //not at limit
						if (slowR == true) {
							motor[right_claw_port] = -45;
						} else {
							motor[right_claw_port] = -100;
						}
						posR = 'G';
				} else {
						motor[right_claw_port] = 0;
						posR = 'F';
						slowR = true; // slow true
				}

			} else { //button not held
				curA = false;
			}


			if (SensorValue[CLAW_FR_SWITCH] == 0 && posR == 'G') { //falling edge RUNS ONCE

							posR = 'M';
							prevPosR = 'F';
							clearTimer(T2);

			}



			if (!curA && prevA) { //falling edge RUNS ONCE
					if (posR == 'F') {
							posR = 'M';
							prevPosR = 'F';
							clearTimer(T2);
					}
					slowR = false;
			}

			if (posR == 'M' && time1[T2] < 300 && prevPosR == 'F') { //move back from FAR TO MIDDLE
					motor[right_claw_port] = 100;
			} else if (posR == 'M' && time1[T2] >= 300 && prevPosR == 'F') {
					motor[right_claw_port] = 0;
					posR = NULL;
					slowR = false;
			}




			// Right claw backward ////////////////////////////////////////////////////////////
			if (left == 1) { //button held
				curB = true;

				if (curB && !prevB) { //rising edge
					//clearTimer(T1);
				}

				if (SensorValue[CLAW_BR_SWITCH] == 1) { //not at limit
						if (slowR == true) {
							motor[right_claw_port] = 45;
						} else {
							motor[right_claw_port] = 100;
						}
						posR = 'G';
				} else {
						motor[right_claw_port] = 0;
						posR = 'C';
						slowR = true; // slow true
				}

			} else { //button not held
				curB = false;
			}

			if (SensorValue[CLAW_BR_SWITCH] == 0 && posR == 'G') { //falling edge RUNS ONCE

							posR = 'M';
							prevPosR = 'C';
							clearTimer(T3);

			}



			if (!curB && prevB) { //falling edge RUNS ONCE
					if (posR == 'C') {
							posR = 'M';
							prevPosR = 'C';
							clearTimer(T3);
					}
					slowR = false;
			}

			if (posR == 'M' && time1[T3] < 400 && prevPosR == 'C') { //move forward from CLOSE TO MIDDLE
					motor[right_claw_port] = -100;
			} else if (posR == 'M' && time1[T3] >= 400 && prevPosR == 'C') {
					motor[right_claw_port] = 0;
					posR = NULL;
					slowR = false;
			}



			prevA = curA;
			prevB = curB;




			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			if (vexRT[Ch3] > 45) {
				up = 1;
			} else {
				up = 0;
			}

			if (vexRT[Ch3] < -45) {
				down = 1;
			} else {
				down = 0;
			}

			if (up == 1) { //button held
				curC = true;

				if (curC && !prevC) { //rising edge
					//clearTimer(T1);
				}

				if (SensorValue[CLAW_FL_SWITCH] == 1) { //not at limit

						if (slowL == true) {
							motor[left_claw_port] = 45;
						} else {
							motor[left_claw_port] = 100;
						}


						posL = 'G';
				} else {
						motor[left_claw_port] = 0;
						posL = 'F';
						slowL = true; // slow true
				}

			} else { //button not held
				curC = false;
			}


			if (SensorValue[CLAW_FL_SWITCH] == 0 && posL == 'G') { //falling edge RUNS ONCE

							posL = 'M';
							prevPosL = 'F';
							clearTimer(T4);

			}



			if (!curC && prevC) { //falling edge RUNS ONCE
					if (posL == 'F') {
							posL = 'M';
							prevPosL = 'F';
							clearTimer(T4);
					}
					slowL = false;
			}

			if (posL == 'M' && time1[T4] < 300 && prevPosL == 'F') {
					motor[left_claw_port] = -100;
			} else if (posL == 'M' && time1[T4] >= 300 && prevPosL == 'F') {
					motor[left_claw_port] = 0;
					posL = NULL;
					slowL = false;
			}






			// left claw backward ////////////////////////////////////////////////////////////
			if (down == 1) { //button held
				curD = true;

				if (curD && !prevD) { //rising edge
					//clearTimer(T1);
				}

				if (SensorValue[CLAW_BL_SWITCH] == 1) { //not at limit
						if (slowL == true) {
							motor[left_claw_port] = -45;
						} else {
							motor[left_claw_port] = -100;
						}
						posL = 'G';
				} else {
						motor[left_claw_port] = 0;
						posL = 'C';
						slowL = true;
				}

			} else { //button not held
				curD = false;
			}

			if (SensorValue[CLAW_BL_SWITCH] == 0 && posL == 'G') { //falling edge RUNS ONCE

							posL = 'M';
							prevPosL = 'C';
							clearTimer(T1);

			}



			if (!curD && prevD) { //falling edge RUNS ONCE
					if (posL == 'C') {
							posL = 'M';
							prevPosL = 'C';
							clearTimer(T1);
					}
					slowL = false;
			}

			if (posL == 'M' && time1[T1] < 300 && prevPosL == 'C') {
					motor[left_claw_port] = 100;
			} else if (posL == 'M' && time1[T1] >= 300 && prevPosL == 'C') {
					motor[left_claw_port] = 0;
					posL = NULL;
					slowL = false;
			}



			prevC = curC;
			prevD = curD;

	}



}
