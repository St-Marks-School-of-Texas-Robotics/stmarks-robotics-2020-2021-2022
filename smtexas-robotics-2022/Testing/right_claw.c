#pragma config(Sensor, dgtl1,  CLAW_FL_SWITCH, sensorDigitalIn)
#pragma config(Sensor, dgtl2,  CLAW_BL_SWITCH, sensorDigitalIn)
#pragma config(Sensor, dgtl3,  CLAW_FR_SWITCH, sensorDigitalIn)
#pragma config(Sensor, dgtl4,  CLAW_BR_SWITCH, sensorDigitalIn)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define LEFT_CLAW_MOTOR port4
#define RIGHT_CLAW_MOTOR port5

bool curA = false;
bool prevA = false;
bool curB = false;
bool prevB = false;

bool curC = false;
bool prevC = false;
bool curD = false;
bool prevD = false;

int up = 0;
int down = 0;


char posR = NULL;
char prevPosR = NULL;
char posL = NULL;
char prevPosL = NULL;


task main()
{
	clearDebugStream();
	while (true) {
		// Right claw forward

			if (vexRT[Btn6D] == 1) { //button held
				curA = true;

				if (curA && !prevA) { //rising edge
					//clearTimer(T1);
				}

				if (SensorValue[CLAW_FR_SWITCH] == 1) { //not at limit
						motor[RIGHT_CLAW_MOTOR] = -100;
						posR = 'G';
				} else {
						motor[RIGHT_CLAW_MOTOR] = 0;
						posR = 'F';
				}

			} else { //button not held
				curA = false;
			}


			if (SensorValue[CLAW_FR_SWITCH] == 0 && posR == 'G') { //falling edge RUNS ONCE

							posR = 'M';
							prevPosR = 'F';
							clearTimer(T2);

			}



			if (!curA && prevA) { //falling edge RUNS ONCE
					if (posR == 'F') {
							posR = 'M';
							prevPosR = 'F';
							clearTimer(T2);
					}
			}

			if (posR == 'M' && time1[T2] < 300 && prevPosR == 'F') {
					motor[RIGHT_CLAW_MOTOR] = 100;
			} else if (posR == 'M' && time1[T2] >= 300 && prevPosR == 'F') {
					motor[RIGHT_CLAW_MOTOR] = 0;
					posR = NULL;
			}




			// Right claw backward ////////////////////////////////////////////////////////////
			if (vexRT[Btn6U] == 1) { //button held
				curB = true;

				if (curB && !prevB) { //rising edge
					//clearTimer(T1);
				}

				if (SensorValue[CLAW_BR_SWITCH] == 1) { //not at limit
						motor[RIGHT_CLAW_MOTOR] = 100;
						posR = 'G';
				} else {
						motor[RIGHT_CLAW_MOTOR] = 0;
						posR = 'C';
				}

			} else { //button not held
				curB = false;
			}

			if (SensorValue[CLAW_BR_SWITCH] == 0 && posR == 'G') { //falling edge RUNS ONCE

							posR = 'M';
							prevPosR = 'C';
							clearTimer(T3);

			}



			if (!curB && prevB) { //falling edge RUNS ONCE
					if (posR == 'C') {
							posR = 'M';
							prevPosR = 'C';
							clearTimer(T3);
					}
			}

			if (posR == 'M' && time1[T3] < 400 && prevPosR == 'C') {
					motor[RIGHT_CLAW_MOTOR] = -100;
			} else if (posR == 'M' && time1[T3] >= 400 && prevPosR == 'C') {
					motor[RIGHT_CLAW_MOTOR] = 0;
					posR = NULL;
			}



			prevA = curA;
			prevB = curB;






	}



}
