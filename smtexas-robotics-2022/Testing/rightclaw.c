#pragma config(Sensor, dgtl3,  CLAW_FR_SWITCH, sensorDigitalIn)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define RIGHT_CLAW_MOTOR port5


//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                        - Wait for Push 1 -                                         *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program instructs the robot to move forward at half speed until the bumper sensor is         *|
|*  pressed.  There is a two second pause at the beginning of the program.                            *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Reversing 'rightMotor' (port 2) in the "Motors and Sensors Setup" is needed with the        *|
|*        "Squarebot" mode, but may not be needed for all robot configurations.                       *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor Port 2        rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor Port 3        leftMotor           VEX 3-wire module     Left side motor                   *|
|*    Digital Port 6      touchSensor         VEX Bumper Switch     Front mounted, facing forward.    *|
\*-----------------------------------------------------------------------------------------------4246-*/

// STATES
//int hinge_position = 0; // hole 0 is no hole
bool hinge_postion = false;

// state tracker to only call button function once when pressed
//false when not pressed, true when pressed
bool hinge_drop_pressed = false; // right pad right button

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
	while(true) {

		// reset button state when button is released
	if (vexRT[Btn6D] != 1) {	// right pad right button
		hinge_drop_pressed = false; // reset state to false
	}

	// rotate to next hole when button pressed for first time after release
	// 		right pad right button
	if (vexRT[Btn6D] == 1  && hinge_drop_pressed == false) {
		hinge_postion = !hinge_postion; // increment flag motor allignment to num hole, avoid exceeding 3

		hinge_drop_pressed = true; // set state to true to not call function until after another button release
	}
			// set the servo value according to the hole number
	switch (hinge_postion) {
		case false: // open position
			//motor[hinge_port] = 0;

			break;

		case true: // close position

			set_position('F')
			break;
		}

	}

}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void set_position(char position){
		if (position == 'F'){   //far
  				if ( SensorValue[CLAW_FR_SWITCH] != 0) {
  						//clearTimer(T1);
							motor[RIGHT_CLAW_MOTOR] = -35;
					}

					//time = time1[T1] //milliseconds

					currPipe = 'F';

  		}


  		if (position == 'M'){    //Middle

  				if ( curPipe == 'F') {
  						clearTimer(T1);

  						if (time1[T1] < time) {
  								motor[RIGHT_CLAW_MOTOR] = -35;
  						}
					}

					curPipe = 'M';


  		}

}
