#pragma config(Sensor, dgtl3,  CLAW_FR_SWITCH, sensorDigitalIn)
#pragma config(Sensor, dgtl4,  CLAW_BR_SWITCH, sensorDigitalIn)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define RIGHT_CLAW_MOTOR port5

bool curA = false;
bool prevA = false;
bool curB = false;
bool prevB = false;
char pos = NULL;
char prevPos = NULL;


task main()
{
	clearDebugStream();
	while (true) {
		// Right claw forward

			if (vexRT[Btn6D] == 1) { //button held
				curA = true;

				if (curA && !prevA) { //rising edge
					clearTimer(T1);
				}

				if (SensorValue[CLAW_FR_SWITCH] == 1) { //not at limit
						motor[RIGHT_CLAW_MOTOR] = -100;
				} else {
						motor[RIGHT_CLAW_MOTOR] = 0;
						pos = 'F';
				}

			} else { //button not held
				curA = false;
			}



			if (!curA && prevA) { //falling edge RUNS ONCE
					if (pos == 'F') {
							pos = 'M';
							prevPos = 'F'
							clearTimer(T2);
					}
			}

			if (pos == 'M' && time1[T2] < 300) {
					motor[RIGHT_CLAW_MOTOR] = 100;
			} else if (pos == 'M' && time1[T2] >= 300 && prevPos == 'F') {
					motor[RIGHT_CLAW_MOTOR] = 0;
					pos = NULL;
			}




			// Right claw backward ////////////////////////////////////////////////////////////
			if (vexRT[Btn6U] == 1) { //button held
				curB = true;

				if (curB && !prevB) { //rising edge
					clearTimer(T1);
				}

				if (SensorValue[CLAW_BR_SWITCH] == 1) { //not at limit
						motor[RIGHT_CLAW_MOTOR] = 100;
				} else {
						motor[RIGHT_CLAW_MOTOR] = 0;
						pos = 'C';
				}

			} else { //button not held
				curB = false;
			}



			if (!curB && prevB) { //falling edge RUNS ONCE
					if (pos == 'C') {
							pos = 'M';
							prevPos = 'C'
							clearTimer(T3);
					}
			}

			if (pos == 'M' && time1[T3] < 300) {
					motor[RIGHT_CLAW_MOTOR] = -100;
			} else if (pos == 'M' && time1[T3] >= 300 && prevPos == 'C') {
					motor[RIGHT_CLAW_MOTOR] = 0;
					pos = NULL;
			}



			prevA = curA;
			prevB = curB;



	}



}
